# 배열

## 배열의 특징

- 고정된 크기를 가진다.
- 일반적으로 동적으로 크기를 늘릴 수 없다.
  → 자바스크립트와 같은 스크립팅 언어는 동적으로 크기가 증감되도록 만들어져 있다.
- 삭제하는 원소의 index를 알고 있다면 O(1)로 원소를 찾을 수 있다.
- 원소를 삭제하면 해당 index에는 빈자리가 생긴다.
  → 해당 번호를 당기지 않고, 빈자리로 남는다.

### 배열 요소의 삭제

삭제 후 순서를 맞추려면 선형시간 O(n)이 걸린다.

### 배열 요소의 추가

중간에 요소를 추가하면 선형시간 O(n)이 걸린다.

⇒ 즉 **추가, 삭제**가 반복되는 로직이라면 배열 사용을 권장하지 않는다.

⇒ 배열은 탐색이 많은 경우에 유리하다.

### 배열생성

```jsx
//빈 array 생성
let arr = [];

//초기화 된 array 생성
let arr2 = [1, 2, 3, 4, 5];

//fill로 초기화 된 array 생성 - 많은 같은 값으 초기화하는 경우 사용한다.
let arr3 = Array(10).fill(0);

//특정 로직을 사용하여 초기화
let arr4 = Array.from({ length: 100 }, (_, i) => i);
console.log(arr4);
```

### 배열 요소 추가, 삭제

```jsx
const arr = [1, 2, 3];

console.log(arr);

arr.push(4);
arr.push(5, 6);

console.log(arr);

arr.splice(3, 0, 222); //O(n) - 선형구조
console.log(arr);

arr.splice(3, 1); //O(n) - 선형구조
console.log(arr);
```

### 자바스크립트 배열 사용시 주의점

- 배열의 크기가 고정되어있지 않고, 필요에 따라 늘어나고 줄어든다.
- 배열의 키 값이 논리값도 들어갈 수 있다.
  → 배열이 근본적으로 객체이기 때문이다.
- 하지만 배열은 length로 관리된다.
  → index가 아닌 키를 사용하는 경우 length에는 영향을 주지 않는다.

⇒ 자바스크립트 언어만의 특징이므로 기억을 해두는 것이 좋다.

⇒ 하지만, 배열에 있는 index key에 논리값을 할당하여 구현하는 것이 좋은 현상을 아니다.

# 배열과 객체

## 배열

- 연관된 데이터를 연속적인 형태로 저장하는 복합 타입이다.
- 배열에 포함 되어있는 원소는 순서대로 번호(index)가 붙는다.

### 배열 생성 예시

```jsx
const arr1 = new Array();
console.log(arr1); //[]

const arr2 = [];
console.log(arr2); //[]

const arr3 = [1, 2, 3, 4, 5];
console.log(arr3); //[ 1, 2, 3, 4, 5 ]

const arr4 = new Array(5);
console.log(arr4); //[empty × 5]  - 빈 값으로 초기화

const arr5 = new Array(5).fill(5);
console.log(arr5); //[ 5, 5, 5, 5, 5 ] - fill을 사용하여 특정값으로 초기화

const arr6 = Array.from(Array(5), function (v, i) {
  return i + 1;
});

console.log(arr6);
```

### 배열 길이 조작

```jsx
const arr = [1, 2, 3];
arr.length = 5;
console.log(arr); //[1, 2, 3, empty × 2]
```

→ 하지만 이러한 방법을 사용하는 것은 추천되지 않는다.

### 다양한 배열 함수

- `join` - 배열을 특정 인자와 함꼐 string값으로 치환하여 연결한다.
- `reverse` - 원본 배열을 역순으로 정렬한다.

```jsx
const arr = [1, 2, 3, 4, 5];
console.log(arr.join(", ")); //1, 2, 3, 4, 5

console.log(arr.reverse()); //[ 5, 4, 3, 2, 1 ]
//주의! - 원본 배열에 영향을 준다.
```

- `concat` - 배열을 연결한다.

```jsx
const arr1 = [1, 2, 3];
const arr2 = [7, 8, 9];
console.log(arr1.concat(arr2)); // [ 1, 2, 3, 7, 8, 9 ]
```

- `push` - 배열 끝에 추가
- `pop` - 배열 끝 값 삭제

```jsx
const arr = [1, 2, 3, 4, 5];
arr.push(6);
arr.push(7, 8, 9);
console.log(arr); //[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]

arr.pop();
arr.pop();
console.log(arr); //[ 1, 2, 3, 4, 5, 6, 7 ]
```

- `shift` - 배열 앞 값 삭제
- `unshift` - 배열 앞 값 추가

```jsx
const arr = [1, 2, 3, 4, 5];
arr.shift();
arr.shift();
console.log(arr); //[ 3, 4, 5 ]
arr.unshift(1);
console.log(arr); //[ 1, 3, 4, 5 ]
```

- `slice` - 배열의 특정 범위를 잘라서 반환 (원본 배열을 조작하지 않고 copy한다)

```jsx
const arr = [1, 2, 3, 4, 5];
console.log(arr.slice(1, 3)); // [ 2, 3 ]
```

- `splice` - 원본 배열의 특정 범위를 잘라낸다.

```jsx
const arr = [1, 2, 3, 4, 5, 6];
arr.splice(2, 2);
console.log(arr); //[ 1, 2, 5, 6 ]
```
